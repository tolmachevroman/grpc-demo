// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "dashboard.proto" (package "dashboard", syntax proto3)
// tslint:disable
import { ServiceType } from '@protobuf-ts/runtime-rpc';
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
/**
 * The main dashboard state containing all fields
 *
 * @generated from protobuf message dashboard.DashboardState
 */
export interface DashboardState {
  /**
   * Text fields
   *
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * @generated from protobuf field: string status_message = 3
   */
  statusMessage: string;
  /**
   * Boolean switches
   *
   * @generated from protobuf field: bool is_enabled = 4
   */
  isEnabled: boolean;
  /**
   * @generated from protobuf field: bool maintenance_mode = 5
   */
  maintenanceMode: boolean;
  /**
   * @generated from protobuf field: bool notifications_on = 6
   */
  notificationsOn: boolean;
  /**
   * Numeric fields
   *
   * @generated from protobuf field: int32 user_count = 7
   */
  userCount: number;
  /**
   * @generated from protobuf field: double temperature = 8
   */
  temperature: number;
  /**
   * @generated from protobuf field: int32 progress_percentage = 9
   */
  progressPercentage: number;
  /**
   * Enum field for dropdown/selection
   *
   * @generated from protobuf field: dashboard.Priority priority = 10
   */
  priority: Priority;
  /**
   * Timestamp for last update
   *
   * @generated from protobuf field: int64 last_updated = 11
   */
  lastUpdated: bigint;
  /**
   * Additional config as key-value pairs
   *
   * @generated from protobuf field: map<string, string> config = 12
   */
  config: {
    [key: string]: string;
  };
}
/**
 * Request to get current dashboard state
 *
 * Could add filters or specific field requests here if needed
 *
 * @generated from protobuf message dashboard.GetDashboardRequest
 */
export interface GetDashboardRequest {}
/**
 * Response with current dashboard state
 *
 * @generated from protobuf message dashboard.GetDashboardResponse
 */
export interface GetDashboardResponse {
  /**
   * @generated from protobuf field: dashboard.DashboardState state = 1
   */
  state?: DashboardState;
}
/**
 * Request to update specific fields
 *
 * @generated from protobuf message dashboard.UpdateDashboardRequest
 */
export interface UpdateDashboardRequest {
  /**
   * Using field_mask would be more proper, but for simplicity:
   * Client sends only the fields they want to update
   *
   * @generated from protobuf field: dashboard.DashboardState updates = 1
   */
  updates?: DashboardState;
  /**
   * List of field names being updated
   *
   * @generated from protobuf field: repeated string updated_fields = 2
   */
  updatedFields: string[];
}
/**
 * Response after update
 *
 * @generated from protobuf message dashboard.UpdateDashboardResponse
 */
export interface UpdateDashboardResponse {
  /**
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * @generated from protobuf field: string message = 2
   */
  message: string;
  /**
   * @generated from protobuf field: dashboard.DashboardState state = 3
   */
  state?: DashboardState;
}
/**
 * Stream request for real-time updates
 *
 * @generated from protobuf message dashboard.StreamDashboardRequest
 */
export interface StreamDashboardRequest {
  /**
   * Client ID for tracking
   *
   * @generated from protobuf field: string client_id = 1
   */
  clientId: string;
}
/**
 * Stream response with updates
 *
 * @generated from protobuf message dashboard.StreamDashboardResponse
 */
export interface StreamDashboardResponse {
  /**
   * @generated from protobuf field: dashboard.DashboardState state = 1
   */
  state?: DashboardState;
  /**
   * @generated from protobuf field: string updated_by = 2
   */
  updatedBy: string;
  /**
   * @generated from protobuf field: repeated string updated_fields = 3
   */
  updatedFields: string[];
}
/**
 * Priority enum for dropdown selection
 *
 * @generated from protobuf enum dashboard.Priority
 */
export enum Priority {
  /**
   * @generated from protobuf enum value: PRIORITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: PRIORITY_LOW = 1;
   */
  LOW = 1,
  /**
   * @generated from protobuf enum value: PRIORITY_MEDIUM = 2;
   */
  MEDIUM = 2,
  /**
   * @generated from protobuf enum value: PRIORITY_HIGH = 3;
   */
  HIGH = 3,
  /**
   * @generated from protobuf enum value: PRIORITY_CRITICAL = 4;
   */
  CRITICAL = 4,
}
// @generated message type with reflection information, may provide speed optimized methods
class DashboardState$Type extends MessageType<DashboardState> {
  constructor() {
    super('dashboard.DashboardState', [
      { no: 1, name: 'title', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'description', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'status_message', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'is_enabled', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 5, name: 'maintenance_mode', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 6, name: 'notifications_on', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 7, name: 'user_count', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 8, name: 'temperature', kind: 'scalar', T: 1 /*ScalarType.DOUBLE*/ },
      { no: 9, name: 'progress_percentage', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 10, name: 'priority', kind: 'enum', T: () => ['dashboard.Priority', Priority, 'PRIORITY_'] },
      { no: 11, name: 'last_updated', kind: 'scalar', T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
      { no: 12, name: 'config', kind: 'map', K: 9 /*ScalarType.STRING*/, V: { kind: 'scalar', T: 9 /*ScalarType.STRING*/ } },
    ]);
  }
  create(value?: PartialMessage<DashboardState>): DashboardState {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.title = '';
    message.description = '';
    message.statusMessage = '';
    message.isEnabled = false;
    message.maintenanceMode = false;
    message.notificationsOn = false;
    message.userCount = 0;
    message.temperature = 0;
    message.progressPercentage = 0;
    message.priority = 0;
    message.lastUpdated = 0n;
    message.config = {};
    if (value !== undefined) reflectionMergePartial<DashboardState>(this, message, value);
    return message;
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DashboardState): DashboardState {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */ 1:
          message.title = reader.string();
          break;
        case /* string description */ 2:
          message.description = reader.string();
          break;
        case /* string status_message */ 3:
          message.statusMessage = reader.string();
          break;
        case /* bool is_enabled */ 4:
          message.isEnabled = reader.bool();
          break;
        case /* bool maintenance_mode */ 5:
          message.maintenanceMode = reader.bool();
          break;
        case /* bool notifications_on */ 6:
          message.notificationsOn = reader.bool();
          break;
        case /* int32 user_count */ 7:
          message.userCount = reader.int32();
          break;
        case /* double temperature */ 8:
          message.temperature = reader.double();
          break;
        case /* int32 progress_percentage */ 9:
          message.progressPercentage = reader.int32();
          break;
        case /* dashboard.Priority priority */ 10:
          message.priority = reader.int32();
          break;
        case /* int64 last_updated */ 11:
          message.lastUpdated = reader.int64().toBigInt();
          break;
        case /* map<string, string> config */ 12:
          this.binaryReadMap12(message.config, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw') throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  private binaryReadMap12(map: DashboardState['config'], reader: IBinaryReader, options: BinaryReadOptions): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof DashboardState['config'] | undefined,
      val: DashboardState['config'][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = reader.string();
          break;
        default:
          throw new globalThis.Error('unknown map entry field for dashboard.DashboardState.config');
      }
    }
    map[key ?? ''] = val ?? '';
  }
  internalBinaryWrite(message: DashboardState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string title = 1; */
    if (message.title !== '') writer.tag(1, WireType.LengthDelimited).string(message.title);
    /* string description = 2; */
    if (message.description !== '') writer.tag(2, WireType.LengthDelimited).string(message.description);
    /* string status_message = 3; */
    if (message.statusMessage !== '') writer.tag(3, WireType.LengthDelimited).string(message.statusMessage);
    /* bool is_enabled = 4; */
    if (message.isEnabled !== false) writer.tag(4, WireType.Varint).bool(message.isEnabled);
    /* bool maintenance_mode = 5; */
    if (message.maintenanceMode !== false) writer.tag(5, WireType.Varint).bool(message.maintenanceMode);
    /* bool notifications_on = 6; */
    if (message.notificationsOn !== false) writer.tag(6, WireType.Varint).bool(message.notificationsOn);
    /* int32 user_count = 7; */
    if (message.userCount !== 0) writer.tag(7, WireType.Varint).int32(message.userCount);
    /* double temperature = 8; */
    if (message.temperature !== 0) writer.tag(8, WireType.Bit64).double(message.temperature);
    /* int32 progress_percentage = 9; */
    if (message.progressPercentage !== 0) writer.tag(9, WireType.Varint).int32(message.progressPercentage);
    /* dashboard.Priority priority = 10; */
    if (message.priority !== 0) writer.tag(10, WireType.Varint).int32(message.priority);
    /* int64 last_updated = 11; */
    if (message.lastUpdated !== 0n) writer.tag(11, WireType.Varint).int64(message.lastUpdated);
    /* map<string, string> config = 12; */
    for (let k of globalThis.Object.keys(message.config))
      writer
        .tag(12, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k)
        .tag(2, WireType.LengthDelimited)
        .string(message.config[k])
        .join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dashboard.DashboardState
 */
export const DashboardState = new DashboardState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDashboardRequest$Type extends MessageType<GetDashboardRequest> {
  constructor() {
    super('dashboard.GetDashboardRequest', []);
  }
  create(value?: PartialMessage<GetDashboardRequest>): GetDashboardRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<GetDashboardRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDashboardRequest): GetDashboardRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === 'throw') throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: GetDashboardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dashboard.GetDashboardRequest
 */
export const GetDashboardRequest = new GetDashboardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDashboardResponse$Type extends MessageType<GetDashboardResponse> {
  constructor() {
    super('dashboard.GetDashboardResponse', [{ no: 1, name: 'state', kind: 'message', T: () => DashboardState }]);
  }
  create(value?: PartialMessage<GetDashboardResponse>): GetDashboardResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<GetDashboardResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDashboardResponse): GetDashboardResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* dashboard.DashboardState state */ 1:
          message.state = DashboardState.internalBinaryRead(reader, reader.uint32(), options, message.state);
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw') throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: GetDashboardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* dashboard.DashboardState state = 1; */
    if (message.state) DashboardState.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dashboard.GetDashboardResponse
 */
export const GetDashboardResponse = new GetDashboardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDashboardRequest$Type extends MessageType<UpdateDashboardRequest> {
  constructor() {
    super('dashboard.UpdateDashboardRequest', [
      { no: 1, name: 'updates', kind: 'message', T: () => DashboardState },
      { no: 2, name: 'updated_fields', kind: 'scalar', repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<UpdateDashboardRequest>): UpdateDashboardRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.updatedFields = [];
    if (value !== undefined) reflectionMergePartial<UpdateDashboardRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateDashboardRequest): UpdateDashboardRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* dashboard.DashboardState updates */ 1:
          message.updates = DashboardState.internalBinaryRead(reader, reader.uint32(), options, message.updates);
          break;
        case /* repeated string updated_fields */ 2:
          message.updatedFields.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw') throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: UpdateDashboardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* dashboard.DashboardState updates = 1; */
    if (message.updates) DashboardState.internalBinaryWrite(message.updates, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    /* repeated string updated_fields = 2; */
    for (let i = 0; i < message.updatedFields.length; i++) writer.tag(2, WireType.LengthDelimited).string(message.updatedFields[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dashboard.UpdateDashboardRequest
 */
export const UpdateDashboardRequest = new UpdateDashboardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDashboardResponse$Type extends MessageType<UpdateDashboardResponse> {
  constructor() {
    super('dashboard.UpdateDashboardResponse', [
      { no: 1, name: 'success', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 2, name: 'message', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'state', kind: 'message', T: () => DashboardState },
    ]);
  }
  create(value?: PartialMessage<UpdateDashboardResponse>): UpdateDashboardResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    message.message = '';
    if (value !== undefined) reflectionMergePartial<UpdateDashboardResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateDashboardResponse): UpdateDashboardResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* string message */ 2:
          message.message = reader.string();
          break;
        case /* dashboard.DashboardState state */ 3:
          message.state = DashboardState.internalBinaryRead(reader, reader.uint32(), options, message.state);
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw') throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: UpdateDashboardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false) writer.tag(1, WireType.Varint).bool(message.success);
    /* string message = 2; */
    if (message.message !== '') writer.tag(2, WireType.LengthDelimited).string(message.message);
    /* dashboard.DashboardState state = 3; */
    if (message.state) DashboardState.internalBinaryWrite(message.state, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dashboard.UpdateDashboardResponse
 */
export const UpdateDashboardResponse = new UpdateDashboardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamDashboardRequest$Type extends MessageType<StreamDashboardRequest> {
  constructor() {
    super('dashboard.StreamDashboardRequest', [{ no: 1, name: 'client_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }]);
  }
  create(value?: PartialMessage<StreamDashboardRequest>): StreamDashboardRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.clientId = '';
    if (value !== undefined) reflectionMergePartial<StreamDashboardRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamDashboardRequest): StreamDashboardRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string client_id */ 1:
          message.clientId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw') throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: StreamDashboardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string client_id = 1; */
    if (message.clientId !== '') writer.tag(1, WireType.LengthDelimited).string(message.clientId);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dashboard.StreamDashboardRequest
 */
export const StreamDashboardRequest = new StreamDashboardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamDashboardResponse$Type extends MessageType<StreamDashboardResponse> {
  constructor() {
    super('dashboard.StreamDashboardResponse', [
      { no: 1, name: 'state', kind: 'message', T: () => DashboardState },
      { no: 2, name: 'updated_by', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'updated_fields', kind: 'scalar', repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<StreamDashboardResponse>): StreamDashboardResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.updatedBy = '';
    message.updatedFields = [];
    if (value !== undefined) reflectionMergePartial<StreamDashboardResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamDashboardResponse): StreamDashboardResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* dashboard.DashboardState state */ 1:
          message.state = DashboardState.internalBinaryRead(reader, reader.uint32(), options, message.state);
          break;
        case /* string updated_by */ 2:
          message.updatedBy = reader.string();
          break;
        case /* repeated string updated_fields */ 3:
          message.updatedFields.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw') throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: StreamDashboardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* dashboard.DashboardState state = 1; */
    if (message.state) DashboardState.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    /* string updated_by = 2; */
    if (message.updatedBy !== '') writer.tag(2, WireType.LengthDelimited).string(message.updatedBy);
    /* repeated string updated_fields = 3; */
    for (let i = 0; i < message.updatedFields.length; i++) writer.tag(3, WireType.LengthDelimited).string(message.updatedFields[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dashboard.StreamDashboardResponse
 */
export const StreamDashboardResponse = new StreamDashboardResponse$Type();
/**
 * @generated ServiceType for protobuf service dashboard.DashboardService
 */
export const DashboardService = new ServiceType('dashboard.DashboardService', [
  { name: 'GetDashboard', options: {}, I: GetDashboardRequest, O: GetDashboardResponse },
  { name: 'UpdateDashboard', options: {}, I: UpdateDashboardRequest, O: UpdateDashboardResponse },
  { name: 'StreamDashboard', serverStreaming: true, options: {}, I: StreamDashboardRequest, O: StreamDashboardResponse },
  { name: 'SyncDashboard', serverStreaming: true, clientStreaming: true, options: {}, I: UpdateDashboardRequest, O: StreamDashboardResponse },
]);
